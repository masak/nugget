* Lexical scoping
* First do it using functions, then we find nice syntactic sugar
* Non-nullable types are the default
* Nudge people towards immutability, but don't punish them for not choosing it
* Make it easy to pretty-print, equality-compare, hash, serialize, and traverse most types
* Eta-transformation (`lambda x: foo(x) == foo`, and `lambda x: obj.foo(x) == obj.foo`)
* Declare/use combinations that can be matched statically
* Instrumenting of the compiler (pragmas, macros)
* Refactoring, refactorability
